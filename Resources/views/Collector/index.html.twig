{% extends 'WebProfilerBundle:Profiler:layout.html.twig' %}

{% block menu %}
    <span class="label">
    <span class="icon">

    </span>
    <strong>CONTAINER</strong>
    <span class="count">
        <span>{{ collector.name }}</span>
    </span>
</span>
{% endblock %}

{% block panel %}
    <h2>Container explorer</h2>
    <div id="container_filter"></div>
    <div id="container_explorer"><h3>Loading...</h3></div>
    <script src="http://d3js.org/d3.v2.min.js"></script>
    <script type="text/javascript">
        var usedServices = {{collector.usedservices|json_encode|raw}};

        var diameter = 900,
            radius = diameter / 2,
            innerRadius = radius - 170;

        var cluster = d3.layout.cluster()
            .size([360, innerRadius])
            .sort(null)
            .value(function(d) { return d.size; });

        var bundle = d3.layout.bundle();

        d3.json("/app_dev.php/_container_json", function(classes) {
            var used      = usedServices.length,
                available = classes.nodes.length,
                payload   = used / available,
                unused    = []
            ;

            classes.nodes.forEach(function(e) {
                e.used = false;
                if (-1 != usedServices.indexOf(e['id']))Â {
                    e.used = true;
                    unused.push(e['id']);
                }
            });

            var nodes   = cluster.nodes(packages.root(classes.nodes)),
                links   = packages.imports(nodes, classes.edges),
                splines = bundle(links)
            ;

            d3.select("#container_filter").html(d3.format('%')(payload) + ' of services used (' + (classes.nodes.length - unused.length) + ' initialized) ');

            var svg = d3.select("#container_explorer").html('').append("svg")
                .attr("width", diameter)
                .attr("height", diameter)
              .append("g")
                .attr("transform", "translate(" + radius + "," + radius + ")")
            ;

            var line = d3.svg.line.radial()
                .interpolate("bundle")
                .tension(.85)
                .radius(function(d) { return d.y; })
                .angle(function(d) { return d.x / 180 * Math.PI; })
            ;

            function mouseover(d) {
                svg.selectAll("path.link.target-" + d.key)
                  .classed("target", true)
                  .each(updateNodes("source", true))
                ;

                svg.selectAll("path.link.source-" + d.key)
                  .classed("source", true)
                  .each(updateNodes("target", true))
                ;
            }

            function mouseout(d) {
                svg.selectAll("path.link.source-" + d.key)
                  .classed("source", false)
                  .each(updateNodes("target", false))
                ;

                svg.selectAll("path.link.target-" + d.key)
                  .classed("target", false)
                  .each(updateNodes("source", false))
                ;
            }

            function updateNodes(name, value) {
                return function(d) {
                    if (value) this.parentNode.appendChild(this);
                    svg.select("#node-" + d[name].key).classed(name, value);
                };
            }

            var path = svg.selectAll("path.link")
                .data(links)
              .enter().append("svg:path")
                .attr("class", function(d, i) {
                    return "link source-" + d.source.key + " target-" + d.target.key;
                })
                .attr("d", function(d, i) {
                    return line(splines[i]);
                });
            ;

            svg.selectAll(".node")
                .data(nodes)
                .enter().append("g")
                  .attr("class", function (d) {return d.used ? 'node used': 'node'; })
                  .attr("id", function(d) { return "node-" + d.key; })
                  .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
                .append("text")
                  .attr("dx", function(d) { return d.x < 180 ? 8 : -8; })
                  .attr("dy", ".31em")
                  .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
                  .attr("transform", function(d) { return d.x < 180 ? null : "rotate(180)"; })
                  .text(function(d) { return d.id; })
                  .on('mouseover', mouseover)
                  .on('mouseout', mouseout)
            ;

            d3.select("input[type=range]").on("change", function() {
                line.tension(this.value / 100);
                path.attr("d", function(d, i) { return line(splines[i]); });
            });
        });

        var packages = {
            // Lazily construct the package hierarchy from class names.
            root: function(classes) {
              var map = {};

              function find(name, data) {
                var node = map[name], i;
                if (!node) {
                  node = map[name] = data || {name: name, children: []};
                  if (name && name.length) {
                    i = name.lastIndexOf("\\");
                    if (i === -1) {
                        i = name.lastIndexOf("_");
                    }
                    node.parent = find(name.substring(0, i));
                    if (typeof node.parent.children == 'undefined') {
                        node.parent.children = [];
                    }
                    node.parent.children.push(node);
                    node.key = name.substring(i + 1);
                  }
                }
                return node;
              }

              classes.forEach(function(d) {
                find(d.class, d);
              });

              return map[""];
            },

            // Return a list of imports for the given array of nodes.
            imports: function(nodes, edges) {
              var map = {},
                  imports = [];

              // Compute a map from name to node.
              nodes.forEach(function(d) {
                map[d.id] = d;
              });

              // For each import, construct a link from the source to target node.
              edges.forEach(function(d) {
                  if (typeof map[d[1]] == 'undefined' ) {
                      //console.log(d[0]);
                  } else if (typeof map[d[0]] == 'undefined') {
                      //console.log(d[1]);
                  } else {
                    imports.push({
                        source: map[d[0]],
                        target: map[d[1]]
                    });
                  }
              });

              return imports;
            }
          };
    </script>
    <style>

.node {
  font: 10px sans-serif;
}

.node.used text {
  fill: green;
}

.link {
  stroke: steelblue;
  stroke-opacity: .5;
  fill: none;
}

path.arc {
  cursor: move;
  fill: #fff;
}

.node {
  font-size: 10px;
  fill: #e00;
}

.node:hover {
  fill: #1f77b4;
  cursor: pointer;
  font-size: 12px;
  font-weight: bold;
}

.link {
  fill: none;
  stroke: #1f77b4;
  stroke-opacity: .4;
  pointer-events: none;
}

.link.source, .link.target {
  stroke-opacity: 1;
  stroke-width: 2px;
}

.node.target {
  fill: #d62728 !important;
  font-size: 12px;
  font-weight: bold;
}

.link.source {
  stroke: #d62728;
}

.node.source {
  fill: #2ca02c;
  font-size: 12px;
  font-weight: bold;
}

.link.target {
  stroke: #2ca02c;
}
</style>
{% endblock %}
